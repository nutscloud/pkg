package net

import (
	"net"
	"sort"
	"testing"
)

// TestIPString2Uint test IPString2Uint
func TestIPString2Uint(t *testing.T) {
	ipUint, err := IPString2Uint("192.168.10.1")
	if err != nil {
		t.Errorf("[TestIPString2Int error] %v", err)
	}
	if ipUint != 3232238081 {
		t.Errorf("[TestIPString2Int error] 192.168.10.1 convert error: %d", ipUint)
	}

	_, err = IPString2Uint("392.168.10.1")
	if err == nil {
		t.Error("[TestIPString2Int error] convertion shoud be error")
	}
}

// TestNetIP2Uint test NetIP2Uint
func TestNetIP2Uint(t *testing.T) {
	ip := net.ParseIP("192.168.10.1")

	ipUint := NetIP2Uint(ip)
	if ipUint != 3232238081 {
		t.Errorf("[TestIPString2Int error] 192.168.10.1 convert errorï¼š %d", ipUint)
	}
}

// TestIPRangeIsOverlap test IPRangeIsOverlap
func TestIPRangeIsOverlap(t *testing.T) {
	ip1 := net.ParseIP("192.169.10.11").To4()
	ip2 := net.ParseIP("192.169.10.20").To4()
	ip3 := net.ParseIP("192.169.10.21").To4()
	ip4 := net.ParseIP("192.169.10.30").To4()
	ip5 := net.ParseIP("192.169.10.15").To4()

	if IPRangeIsOverlap(ip1, ip2, ip3, ip4) {
		t.Error("[TestMinUint error] There is no overlap between [192.169.10.11, 192.169.10.20] and [192.169.10.21, 192.169.10.30]")
	}

	if IPRangeIsOverlap(ip3, ip4, ip1, ip2) {
		t.Error("[TestMinUint error] There is no overlap between [192.169.10.21, 192.169.10.30] and [192.169.10.11, 192.169.10.20]")
	}

	if !IPRangeIsOverlap(ip1, ip2, ip5, ip4) {
		t.Error("[TestMinUint error] There is overlap between [192.169.10.11, 192.169.10.20] and [192.169.10.15, 192.169.10.30]")
	}
}

func TestIPSort(t *testing.T) {
	expectSoredIPs := IPs{
		"12.23.66.142",
		"14.174.115.153",
		"17.234.231.248",
		"22.197.148.36",
		"25.100.75.190",
		"30.200.160.252",
		"37.94.193.220",
		"44.66.162.15",
		"44.145.101.194",
		"45.72.78.158",
		"47.224.223.77",
		"51.76.111.217",
		"52.45.208.52",
		"53.204.221.12",
		"63.201.4.100",
		"78.142.207.96",
		"82.242.85.158",
		"85.13.2.125",
		"85.163.114.200",
		"88.224.161.5",
		"90.205.44.167",
		"91.15.95.96",
		"92.158.87.211",
		"92.188.49.158",
		"95.28.204.121",
		"96.157.236.37",
		"99.252.239.136",
		"101.21.21.150",
		"101.201.94.146",
		"106.151.181.134",
		"106.185.53.112",
		"107.30.151.159",
		"110.163.240.41",
		"110.227.135.118",
		"111.197.96.188",
		"112.143.127.37",
		"117.79.242.178",
		"122.58.38.1",
		"126.44.177.117",
		"131.247.203.211",
		"134.126.214.68",
		"134.174.182.190",
		"138.104.185.203",
		"142.178.242.237",
		"144.22.97.102",
		"152.112.7.3",
		"154.233.43.236",
		"155.18.49.207",
		"155.72.88.219",
		"157.121.37.41",
		"159.62.218.10",
		"163.162.144.42",
		"166.100.83.173",
		"167.76.127.47",
		"169.150.86.165",
		"171.167.226.34",
		"172.21.13.37",
		"172.21.13.120",
		"172.21.13.131",
		"172.21.13.183",
		"190.74.125.214",
		"192.72.253.23",
		"192.118.178.215",
	}

	testIPs := IPs{
		"172.21.13.120",
		"172.21.13.37",
		"172.21.13.183",
		"172.21.13.131",
		"171.167.226.34",
		"134.174.182.190",
		"142.178.242.237",
		"112.143.127.37",
		"47.224.223.77",
		"155.18.49.207",
		"144.22.97.102",
		"30.200.160.252",
		"192.72.253.23",
		"17.234.231.248",
		"90.205.44.167",
		"101.21.21.150",
		"51.76.111.217",
		"82.242.85.158",
		"44.66.162.15",
		"101.201.94.146",
		"12.23.66.142",
		"159.62.218.10",
		"192.118.178.215",
		"78.142.207.96",
		"85.163.114.200",
		"169.150.86.165",
		"190.74.125.214",
		"63.201.4.100",
		"44.145.101.194",
		"25.100.75.190",
		"95.28.204.121",
		"107.30.151.159",
		"14.174.115.153",
		"167.76.127.47",
		"163.162.144.42",
		"45.72.78.158",
		"85.13.2.125",
		"166.100.83.173",
		"155.72.88.219",
		"138.104.185.203",
		"92.188.49.158",
		"110.163.240.41",
		"152.112.7.3",
		"131.247.203.211",
		"96.157.236.37",
		"22.197.148.36",
		"53.204.221.12",
		"134.126.214.68",
		"126.44.177.117",
		"111.197.96.188",
		"91.15.95.96",
		"52.45.208.52",
		"37.94.193.220",
		"157.121.37.41",
		"99.252.239.136",
		"154.233.43.236",
		"88.224.161.5",
		"117.79.242.178",
		"106.185.53.112",
		"110.227.135.118",
		"122.58.38.1",
		"106.151.181.134",
		"92.158.87.211",
	}

	sort.Sort(testIPs)
	for i := range testIPs {
		if testIPs[i] != expectSoredIPs[i] {
			t.Errorf("%s != %s", testIPs[i], expectSoredIPs[i])
		}
	}
}
